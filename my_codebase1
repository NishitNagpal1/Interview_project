from fastapi import FastAPI
from databases import Database
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, JSON
import random
from sqlalchemy.sql import select
from pydantic import BaseModel



DATABASE_URL = "postgresql+asyncpg://postgre:password@localhost:5432/question_bank"



database = Database(DATABASE_URL)
metadata = MetaData()


questions_table = Table(
    "questions",
    metadata,
    Column("id", Integer, primary_key=True),
    Column("question", String, nullable=False),
    Column("options", JSON, nullable=False),
    Column("answer", String, nullable=False),
)

engine = create_engine(DATABASE_URL.replace("asyncpg", "psycopg2"))
metadata.create_all(engine)


app = FastAPI()


class AnswerSubmission(BaseModel):
    question_id: int
    submitted_answer: str

@app.on_event("startup")
async def startup():
    await database.connect()


@app.get("/questions")
async def get_random_questions(count: int = 10):
    """
    Fetch `count` random questions from the database.
    """
    query = select([questions_table])
    rows = await database.fetch_all(query)
    all_questions = [{"id": row["id"], "question": row["question"], "options": row["options"], "answer": row["answer"]} for row in rows]

    if count > len(all_questions):
        count = len(all_questions)
    random_questions = random.sample(all_questions, count)
    return {"questions": random_questions}

@app.post("/submit")
async def submit_answer(answer: AnswerSubmission):
    query = select([questions_table]).where(questions_table.c.id == answer.question_id)
    question = await database.fetch_one(query)
    if not question:
        return {"error": "Question not found"}
    correct = question["answer"] == answer.submitted_answer
    return {"correct": correct}

@app.on_event("shutdown")
async def shutdown():
    await database.disconnect()
